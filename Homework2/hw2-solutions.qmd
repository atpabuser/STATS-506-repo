---
title: "HW2 Solutions"
format: html
editor: visual
---

# Problem 1

Consider a 1-dimensional random walk with the following rules:

1.  Start at 0.
2.  At each step, move +1 or -1 with 50/50 probability. If +1 is chosen, 5% of the time move +10 instead. If -1 is chosen, 20% of the time move -3 instead. Repeat steps 2-4 $n$ times. (Note that if the +10 is chosen, it’s not +1 then +10, it is just +10.)

Write a function to determine the end position of this random walk.

The input and output should be:

Input: The number of steps Output: The final position of the walk

### Version 1: Using a loop

**Marginal computations:**

-   (+1): $0.5 \times 0.95 = 0.475$
-   (+10): $0.5 \times 0.05 = 0.025$
-   (–1): $0.5 \times 0.80 = 0.40$
-   (–3): $0.5 \times 0.20 = 0.10$

```{r}
#' Random Walk Simulation
#'
#' Simulate a 1d random walk. At each step, the walker moves +1 or -1 with
#' 50-50 odds.+1 becomes +10 with 5% chance, and -1 becomes -3 with 20% odds
#'
#' @param n The number of steps
#' @return the final position of the walk

random_walk1 <- function(n) {
  #Start at position 0
  position <- 0
  #steps vector
  steps <- c(1,10,-1,-3)
  probabilities <-c(0.475, 0.025, 0.400, 0.100)
  
  for (i in 1:n){
  #do single random draw to get move for the step 
    move <-sample(x=steps, size=1, prob=probabilities)
  
  #update position
    position <- position + move
  }
  return(position)
}
```

### Version 2: No loop, vectorized

To answer the question: The order of steps does not matter, we only need the final position since the final position, (the sum), is the sum of i.i.d steps

```{r}
#' Vectorized 1D Random Walk Simulation 
#' 
#' @param n The number of steps
#' @return Sum: Final position 
#' 

random_walk2 <- function(n) {
  #steps vector
  steps <- c(1,10,-1,-3)
  probabilities <-c(0.475, 0.025, 0.400, 0.100)
  
  #sample all at once and sum to get final position
  
  return(sum(sample(steps, size = n, replace = TRUE, prob = probabilities)))
}

```

### Version 3: Using `apply()` function

```{r}
#' using sapply() 1D Random Walk Simulation 
#' 
#' @param n The number of steps
#' @return Sum: Final position 
#' 

random_walk3 <- function(n) {
  steps <- c(1,10,-1,-3)
  probabilities <-c(0.475, 0.025, 0.400, 0.100)
  all_steps <- sapply(1:n, function(i) 
    {sample(x=steps, size=1,replace=TRUE, prob=probabilities)})
  
  return(sum(all_steps))
} 

```

### Demonstrate that all versions work by running the following:

```{r}
random_walk1(10)
random_walk2(10)
random_walk3(10)
random_walk1(1000)
random_walk2(1000)
random_walk3(1000)

```

### 1b. Demonstrate that the three versions can give the same result. Show this for both $n=10$ and $n=1000$

To control for randomness, we fix the seed before calling each random_walk function. I will do a different seed for $n=10$ and $n=1000$

### Case 1: $n=10$

```{r}
set.seed(123)
val<-10
cat("The final value for n=",val,"using random_walk1() is:",random_walk1(val))

set.seed(123)
cat("\nThe final value for n=",val,"using random_walk2() is:",random_walk2(val))

set.seed(123)
cat("\nThe final value for n=",val,"using random_walk3() is:",random_walk3(val))


```

### Case 2: $n=1000$

```{r}
set.seed(555)
val2<-1000
cat("The final value for n=",val2,"using random_walk1() is:",random_walk1(val2))

set.seed(555)
cat("\nThe final value for n=",val2,"using random_walk2() is:",random_walk2(val2))

set.seed(555)
cat("\nThe final value for n=",val2,"using random_walk3() is:",random_walk3(val2))

```

### 1c.

Use the microbenchmark package to clearly demonstrate the speed of the implementations.Compare performance with a low input and a large input. Discuss results.

```{r}
library(microbenchmark)
n_val1<-1000
results_nval1 <-microbenchmark(
  loop <- random_walk1(n_val1),
  vectorized <- random_walk2(n_val1),
  apply <- random_walk3(n_val1)
)

print(results_nval1)


```

```{r}

n_val2<-100000
results_nval2 <-microbenchmark(
  loop <- random_walk1(n_val2),
  vectorized <- random_walk2(n_val2),
  apply <- random_walk3(n_val2)
)

print(results_nval2)


```

So, I expected the vectorized function to clearly be the fastest, (which it is in both cases) but I am quite surprised that my for-loop implementation is faster than the implementation using `sapply()`. I did some googling and found out the following links:

1.  https://www.reddit.com/r/rstats/comments/9s778r/in_benchmark_tests_a_forloop_was_almost_50_faster/
2.  https://www.tylermw.com/posts/data_analysis/theres-no-need-to-apply-yourself.html

In either case, however, the best thing to do for the quickest implementation is vectorization. 

### 1d. 

Define a helper function to compute the probability the random walk ends at 0. Use vectorized random_walk implementation. WLOG it does not matter which one I choose as long as I fix the seed. 

```{r}

#' @param n number of steps in the random walk
#' 
#' @param num_sims number of simulations we run
#' 
#' @return estimated probability random walk ends at 0

prob_zero_rw <- function(n,num_sims){
  #run the random walk for the specified simulation size
  final_positions <- numeric(num_sims)
  
  #loop to get final positions
  for (i in 1:num_sims){
    final_positions[i] <- random_walk2(n)
  }
  successes <- sum(final_positions == 0)
  return (successes/num_sims)
}
```

### Case 1: $n$=10
```{r}
set.seed(929)
num_sims <- 10000
prob_10 <- prob_zero_rw(10,num_sims)
cat("The probability of the random walk going to zero after 10 steps is:",prob_10)

```
### Case 2: $n$=100
```{r}
set.seed(929)
num_sims <- 10000
prob_100 <- prob_zero_rw(100,num_sims)
cat("The probability of the random walk going to zero after 100 steps is:",prob_100)

```
### Case 3: $n$=1000
```{r}
set.seed(929)
num_sims <- 10000
prob_1000 <- prob_zero_rw(1000,num_sims)
cat("The probability of the random walk going to zero after 1000 steps is:",prob_1000)

```
As we increase the number of steps, the probability that the random walk ends at 0 converges to 0. As I have shown above, the probability gets closer and closer to 0 as I go from n=10,100,1000. This makes sense because as you increase the number of steps of the random walk, the range of possible positions it ends at grows much larger, so the probability we land at 0 decreases. 

Here is a  graph visualizing this: 

```{r}
set.seed(929)

#define the range of steps we plot
n_values <-seq(10,1000,10)

#compute probabilities
probs <- sapply(n_values, prob_zero_rw,num_sims=5000)
plot(x=n_values, y=probs, col="blue", xlab="Number of Steps", ylab="Probabilities")

```

Can see it converging to 0 as $n$ increases. 

# Problem 2


